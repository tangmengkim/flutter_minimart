import 'dart:convert';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

// A class to hold all secure storage keys in one place.
class DataKeys {
  static const String userToken = 'user_token';
  static const String userProfile = 'user_profile';
  static const String userInfo = 'user_info';
  static const String isUserAuth = 'is_user_auth';
  static const String userAuth = 'user_auth';
}

class Data {
  final FlutterSecureStorage _storage = const FlutterSecureStorage();

  /// Store a value. If it's a String, store directly.
  /// If it has `toJson()`, serialize it as JSON.
  Future<void> put<T>(String key, T value) async {
    if (value is String) {
      await _storage.write(key: key, value: value);
    } else if (value is bool) {
      await _storage.write(key: key, value: value.toString());
    } else {
      // Assume it is JSON-serializable
      final jsonString = json.encode((value as dynamic).toJson());
      await _storage.write(key: key, value: jsonString);
    }
  }

  /// Retrieve a value.
  /// If T is String, return directly.
  /// If T is an object, provide a `fromJson` factory to deserialize.
  Future<T?> get<T>(
    String key, {
    T? defaultValue,
    T Function(Map<String, dynamic>)? fromJson,
  }) async {
    final value = await _storage.read(key: key);
    if (value == null) return defaultValue;

    print(value);
    if (T == String) {
      return value as T;
    }

    if (T == bool) {
      return (value.toLowerCase() == 'true') as T;
    }

    if (fromJson != null) {
      final Map<String, dynamic> jsonMap = json.decode(value);
      return fromJson(jsonMap);
    }

    throw ArgumentError(
      'fromJson is required when reading non-String values of type $T',
    );
  }

  /// Check if a key exists in secure storage.
  Future<bool> containsKey(String key) async {
    return await _storage.containsKey(key: key);
  }

  /// Delete a value by key.
  Future<void> remove(String key) async {
    await _storage.delete(key: key);
  }

  Future<void> removeAll() async {
    await _storage.deleteAll();
  }
}

// import 'dart:convert';

// import 'package:flutter_secure_storage/flutter_secure_storage.dart';

// class Data {
//   final FlutterSecureStorage _storage = const FlutterSecureStorage();

//   // Save a simple string value
//   Future<void> write(String key, String value) async {
//     await _storage.write(key: key, value: value);
//   }

//   // Read a simple string value
//   Future<String?> read(String key, {String? defaultValue}) async {
//     final value = await _storage.read(key: key);
//     return value ?? defaultValue;
//   }

//   // Delete a value
//   Future<void> delete(String key) async {
//     await _storage.delete(key: key);
//   }

//   // Save an object (must be JSON serializable)
//   Future<void> writeObject<T>(String key, T object) async {
//     // Assumes object has a toJson() method (as generated by json_serializable)
//     final jsonString = json.encode((object as dynamic).toJson());
//     await _storage.write(key: key, value: jsonString);
//   }

//   // Check if a key exists
//   Future<bool> containsKey(String key) async {
//     return await _storage.containsKey(key: key);
//   }

//   // Read an object using a fromJson factory (as generated by json_serializable)
//   Future<T?> readObject<T>(
//     String key, {
//     required T Function(Map<String, dynamic>) fromJson,
//     T? defaultValue,
//   }) async {
//     final jsonString = await _storage.read(key: key);
//     if (jsonString == null) return defaultValue;
//     final Map<String, dynamic> jsonMap = json.decode(jsonString);
//     return fromJson(jsonMap);
//   }

//   // Delete all values
//   Future<void> deleteAll() async {
//     await _storage.deleteAll();
//   }
// }
